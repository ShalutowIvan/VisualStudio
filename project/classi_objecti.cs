using System;
using System.Collections.Generic;//это нужно для работы с классом List это списки
namespace project
{
    class classi_objecti
    {
        //классы можно создавать в виде отдельного файла
        static void Main()
        {
            //создаем объект на основе класса robot
            //robot loper = new robot();//robot наподобие типа данных, в качестве типа данных пишем название класса robot, потом пишем название объекта, я назвал объект loper, потом обязатель выделить память пишем new robot()
            //мы создали объект и он имеет доступ ко всем характиристикам из класса robot, там есть три поля, доступ к этим полям у нас есть
            //указываем зарактиристики
            // loper.name = "terminator";
            // loper.ves = 150;
            // loper.coordinates = new byte[] { 0, 0, 0 };//выделяем память под массив
            // System.Console.WriteLine(loper.name + " вес " + loper.ves);

            // robot slayer = new robot();
            // slayer.name = "Killer";
            // slayer.ves = 1000;
            // slayer.coordinates = new byte[] { 0, 0, 50 };
            // System.Console.WriteLine(slayer.name + " вес " + slayer.ves);

            // foreach (byte el in slayer.coordinates)
            // {
            //     System.Console.WriteLine("Координаты " + el);
            // }
            //если добавить новую функцию в класс robot, то она будет доступна для всех объектов, то есть добавим переменную в классе и для все объектов она будет доступна
            //урок про объекты
            // robot slayer2 = new robot();//это из урока про объекты
            // slayer2.setznach("Killer2", 2020, new byte[] { 0, 0, 200 });//обратились к объекту, то есть написали название объекта, потом указали название функции для указания значений, потом указали значения, так как у этой функции есть параметры, память под массив выделили, в каких случаях нужно выделять память пока не понятно. Получается мы все значения указали одной строкой а не несколькими
            // slayer2.printZnach();//выводим сразу все характиристики короткой записью//это из урока про объекты
            //                      // slayer.name = "Killer2";
            //                      // slayer.ves = 1500;
            //                      // slayer.coordinates = new byte[] { 0, 0, 100 };
            //                      // System.Console.WriteLine(slayer.name + " вес " + slayer.ves);
            // System.Console.WriteLine();//это из урока про объекты
            // robot loper2 = new robot();//это из урока про объекты
            // loper2.setznach("Terminator2", 500, new byte[] { 0, 0, 150 });
            // loper2.printZnach();//это из урока про объекты

            //урок про конструкторы
            // robot slayer3 = new robot("Killer3", 2022, new byte[] { 0, 0, 190 });//передаем сразу параметры объекту через конструктор, то есть записываем значения при выделении памяти сразу, а не через функцию, то есть не нужно писать отдельную строку. Если конструкторов несколько, то конструктор будет сразу подбираться тот который мы создали с параметрами, автоматом. 
            // slayer3.printZnach();//выводим в консоль с помощью функции вывода

            // System.Console.WriteLine();
            // robot loper3 = new robot();//тут будет подбираться конструктор который мы создали без параметров автоматом, мы создали объект через пустой конструктор
            // loper3.setznach("Terminator3", 500, new byte[] { 0, 0, 150 });//присвоили значения черех функцию для присваивания значений setznach
            // loper3.printZnach();
            // System.Console.WriteLine();

            // robot kot = new robot("Пушистик", 7, new byte[] { 1, 1, 8 });//создали и присвоили значения объекту через конструктор с 3-мя параметрами
            // kot.printZnach();//вывели значения через функцию
            //                  //пробуем аксессор на коте, он обозначается как гаечный ключ
            // System.Console.WriteLine();
            // System.Console.WriteLine("Аксессоры");
            // System.Console.WriteLine("-------------");
            // //аксессоры
            // kot.Ves = 5;//число не пройдет проверку так как оно меншье 1 и будет присвоено значения 1, мы в set прописали это условие
            // System.Console.WriteLine(kot.Ves);//вывели аксессор на экран, сюда будет дописываться то что прописали в get
            // kot.Width = 10;
            // System.Console.WriteLine(kot.Width);


            // System.Console.WriteLine("-------------");
            // robot pilesos = new robot(115);//создал объект через конструктор
            // //pilesos.setznach("uborka", new byte[] { 0, 4, 14 });// это не работает, так как с помощью конструктора с одним значением можно вернуть только одно значение, и в функции у нас значения и они или затрутся или будет ошибка
            // pilesos.print2();
            // // pilesos.printZnach();//выведет только одно значение, для других будет написана ошибка, скорее всего нужна отдельна фукнция для вывода
            // System.Console.WriteLine();
            // //robot.lopator = 5;//присвоили значение переменной lopator, которую указали в классе robot. Обратиться мы к ней можем, так как модификатор доступа там public, был бы private, то не смогли бы обратиться. это к теме static. В классе robot я сделал ее как счетчик объектов
            // System.Console.WriteLine("количество роботов: " + robot.lopator);//вывели ее в консоль

            // robot.Print();//вызываем функцию, сначала надо писать название класса, потом название функции, так как функция не присваиваивает значение объекту и обращаемся через клас, а не через объект. Просто опробовал функцию из другого класса файла

            // konstruktor_static obj = new konstruktor_static();//создал объект

            // obj.num = 555;
            // System.Console.WriteLine("опробовал переменную объекта " + obj.num);

            //КЛАССЫ НАСЛЕДНИКИ!!!!!!!!!!!!!
            //создаем объект на основе класса наследника
            //конструктор не сработал хз почему, конструктор пока не пишем, так как нужно что-то дописать
            //функции - методы срабатывают из класса родителя срабатывают без проблем, то есть можно писать название класса наслденика и назвнаие функций брать от родителя, так как есть доступ к полям и методам основного класса

            // kot_naslednik kisa = new kot_naslednik();//создали объект на основе класса наследника
            // kisa.setznach("Мурлыса", 80, new byte[] { 4, 4, 15 });//воспользовались функцией из класса родителя, так как наследнику доступны функции класса родителя
            // kisa.printZnach();//вывели в консоль с помощью функции класса родителя, так как наследнику доступны функции класса родителя
            // kisa.Health = 120;//воспользовались аксессором из класса наследника
            // //для класса родителя не будут доступны функции или аксессоры из наследника
            // kisa.Lazer();//воспользовались функцией из класса наследника, это дополнительный функционал

            // kot_naslednik ikote = new kot_naslednik("Саймон", 100, new byte[] { 11, 11, 111 }, 777);
            // //ikote.printZnach();
            // //System.Console.WriteLine(ikote.Health);
            // //теперь вывод будет происходить автоматом, так как мы это прописали в конструкторе в классе наслденике, дописывать вызов функции для вывода в консоль не нужно
            // //ikote.FIO = "saimon";//это не сработает как как переменная с доступом protected и защищена и доступна только в классе родителе и наследнике
            // ikote.pasport();//обратились к этому полю через функцию, написав название объекта, потом точка потом название функции и скобки, так скобки означают что мы вызываем функцию. Также обычные поля без модификатора static нельзя вызвать как просто переменную, а только как свойство объекта. Поэтому мы вывели в консоль свойство объекта
            // kot_naslednik.mer();



            //массив объектов, тема is as!!!!!!!!
            //создаем массив из объектов на основе классов. будет создавать динамический массив
            //List<robot> robots = new List<robot>();//написали класс, потом указали тип данных, вместо типа данных мы написали название родительского класса, потом название списка robots. Потом выделили память под класс и написали круглые скобки
            //  robots.Add(new robot("Tatiana", 100, new byte[] { 0, 1, 10 }));//обратились к названию списка robots и указываем добавление элементов Add, каждый элемент списка это должен быть объект на основе класса robot, в скобках пишем параметры для объекта
            //   robots.Add(new robot("Ivan", 110, new byte[] { 0, 2, 10 }));
            //    robots.Add(new robot("Marina", 150, new byte[] { 0, 3, 10 }));
            //    robots.Add(new robot("Viktor", 20, new byte[] { 0, 4, 10 }));
            //   robots.Add(new robot("Alex", 120, new byte[] { 0, 5, 10 }));
            //     robots.Add(new robot("Elena", 90, new byte[] { 0, 6, 10 }));
            //получается сделали массив из объектов на основе класса robot(в нем есть конструктор для указания таких параметров)
            //перебираем наш массив
            //   foreach (robot obj in robots)   //robot это как бы тип данных, obj это переменная для объекта, далее пишем какой массив то есть список перебираем. Как бы перебираем переную obj в массиве robots, и чтобы вывести элемент массива также выводим эту переменную
            //   {
            //    System.Console.WriteLine(obj.Name);//выводим имя объекта из переменной для объекта name и пользуемся аксессором Name. Был бы цикл for можно было бы написать robots.Name
            //получаетс вывели массив объектов на основе класса robot
            //массив указателей

            //    }
            //создаем новый список объектов на основе класса наследника kot_naslednik
            // List<kot_naslednik> robots2 = new List<kot_naslednik>();

            // robots2.Add(new kot_naslednik("Tatiana", 100, new byte[] { 0, 1, 10 }, 100));//обратились к названию списка robots2 и указываем добавление элементов Add, каждый элемент списка это должен быть объект на основе класса robot, в скобках пишем параметры для объекта
            // robots2.Add(new kot_naslednik("Ivan", 110, new byte[] { 0, 2, 10 }, 100));
            // robots2.Add(new kot_naslednik("Marina", 150, new byte[] { 0, 3, 10 }, 100));
            // robots2.Add(new kot_naslednik("Viktor", 20, new byte[] { 0, 4, 10 }, 100));
            // robots2.Add(new kot_naslednik("Alex", 120, new byte[] { 0, 5, 10 }, 100));
            // robots2.Add(new kot_naslednik("Elena", 90, new byte[] { 0, 6, 10 }, 100));

            // //можно сделать так чтобы можно было обращаться к классу robot, так как kot_naslednik является классом наслденик для robot
            // robot newrobot = null;//создали объект на основе класса robot и присвоили ему значение означающее пустоту
            // foreach (kot_naslednik obj in robots2)
            // {
            //     if (obj.Name == "Elena")//если находится имя Elena то это имя записывается в новый объект newrobot
            //     {
            //         newrobot = obj as robot;//as можно и не писать, он срабатывает автоматом, но не всегда. Запись означает что мы объект приводим к другому классу или тпу данных. То есть был объекта на основе класса kot_naslednik, и мы его приводим в объъект на основе класса robot
            //                                 //в объектах класса kot_naslednik можно обращаться к дополнительным функционалу, то есть к дополнительным функциям. Чтобы обратиться нужно написать obj.Lazer например. А в новом объекте на основе класса robot, нет дополнительных функций и к ним обратиться нельзя через новый объект
            //                                 //по итогу as это такой оператор который преобразовывает объект одного класса файла в объект на основе другого класса

            //     }


            //     // System.Console.WriteLine(obj.Name);
            //     //оператор is позволяет проверить приналлежит ли объект к определенному типу данных, то есть определенному классу, и выводит true или false
            //     System.Console.WriteLine(obj is robot);
            //в нашем случае по всем объектам выведется true, так как они являются наследниками robot
            //System.Console.WriteLine(obj is classi_objecti);//тут будет false
            //с помощью оператора is можно проверить какой тип данных у объекта или переменной
            //его можно использовать в какхи либо условиях, очень удобно

            // }
            // int num = 9;
            // System.Console.WriteLine(num is float);//оператор возвращает либо тру либо фолз
            //или 
            // if (num is int)//можно его писать в условиях
            // {
            //     //бла бла бла
            // }
            robot kaka = new robot("gavno", 150, new byte[] { 0, 0, 100 });
            kaka.printZnach();

            kot_naslednik Tigr = new kot_naslednik("Tigrica", 200, new byte[] { 0, 0, 150 }, 200);
            Tigr.printZnach();




        }


    }
}
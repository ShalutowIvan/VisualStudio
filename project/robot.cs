using System;

namespace project//namespace это пространство имен то есть папка с проектом
{
    class robot
    {
        //в классе можно описать переменные или поля, это одно и тоже. Также можно функции создавать
        //описываем чертеж этого робота
        //потом будем создавать объекты на основе этого класса
        //это будет общая характеристика для всех будущих роботов
        //потом создавать объекты это будут другие роботы
        //список характиристик: название, вес, массив для координат
        //основные модификаторы доступа: public, protected, private
        //public означает что поле будет доступно отовсюду, во всех классах, такж в других объектах которые созданы на основе самого класса, и можно будет присвоить значение переменной объекта без дополнительных функций
        //protected означает что поле будет доступно внутри текущего класса и в классах наследниках, то есть наследники могут присвоить значение свойству объекта не обращаясь к функции
        //private означает поле будет доступно только внутри класса в котором оно находится, в других классах или других объектах не будет возможности ссылаться на поле которое с модификатором доступа private, нужно будет делать функцию и через функцию присваивать значения
        //пишем поля
        private string name;//имя
        private int ves;//вес
        private byte[] coordinates;//координаты
                                   //если вместо public написать private, то нельзя будет к этим полям обращаться через объект в другом классе или файле. Зачем же их делать private
                                   //но это правильная концепция, называется инкапсуляция, и так лучше и правильнее делать, потому что поля должны быть защищены, доступ к ним будет защищен, и это верная концепция для разработки классов
                                   // как к ним обратиться. Внутри самого класса где созданы поля, создать отдельные методы, функции. Через эти функции будем обращаться ко всем этим полям и задавать значения или получать из них значения
                                   //создаем метод для установления значений для всех полей класса текущего, метод возвращать не будет, то есть функция будет одноразовая
                                   //взаимодействия с полями осуществляется через методы и доступ обычно ставим private
        public void setznach(string name, int ves, byte[] coordinates)
        {
            //создали функцию для указания полей, в скобках указали параметры. С помощью параметров этой функции мы можем записать значения в переменные объекта. То есть эту функцию потом вызовем и напишем в ней просто цифры и слова в скобках, то есть значения полей, и эта функция запишет значения в поля в текущем классе. Если бы модификатор доступа был public, то можно было и не писать функцию, а просто создать объект и без функции обратиться к переменной, например написать slayer2.ves = и дальше присвоить значение. Так как модификатор доступа Private, то мы создаем функцию и пишем значения для параметров функции и эти параметры записывают значения в переменные
            this.name = name;//дописали this, это означает что переменная принадлежит к этому классу и название параметра можно написать точно с таким же названием как переменная и ошибка не будет отображаться. Во все других случаях где используются эти же параметры, также можно написать названия параметров совпадающие с этими переменными с this
            this.ves = ves;
            this.coordinates = coordinates;

        }


        public void printZnach()//функция
        {
            System.Console.WriteLine(name + " вес " + ves + ". Координаты: ");
            foreach (byte el in coordinates)
            {
                System.Console.Write(el + " ");
            }
        }

        //такие конструкции могут использоваться к подключению в базе данных и для отключения, то есть создали файл(класс, название класса будет соответствовать названию файла) с функциями для подключения и отключения к базе данных и в другом файле (классе) используем функции из этого класса


        //создаем конструктор
        //можно создать конструктор он будет работать как метод или функция и будет срабатывать при создании объекта(например конструктор для подключения к БД)
        //конструкторы ничего не возвращают, они проделывают манипуляции, но ничего не возвращают. Тип данных в них указывать не нужно, и void (пустой тип данных) тоже писать не нужно
        // название самого конструктора должно быть такое же как название класса и файла *.cs
        //   в любом классе и файле он есть, но он по умолчанию не видимый и ничего не делает, но его можно написать и прописать в него что-то
        // код из конструктора который приписан в какой либо классе(например у нас есть класс с названием robot и в нем есть конструктор) срабатывает каждый когда в другой функции и в другом классе файле создается объект на основе этого класса, например создаем объект в одном файле(название любое) на основе другого класса файла в котором есть конструктор, и код из конструктора сработает. Если создать в третьем файле классе конструктор и если его не вызывать, то срабатывать конструктор из других файлов не будет
        //то есть конструтор это дополнительный функционал в каком либо классе, который срабатывает автоматом при использщовании класса для создания объекта
        //местоположение конструтора в классе не имеет значения, то есть написать его можно в любой части класса
        //если создать конструктор с модификатором доступа private то создание объектов на основе класса будет не доступно




        //конструкторы
        public robot(string name, int ves, byte[] coordinates)//конструктор с 3-мя параметрами
        {
            System.Console.WriteLine("Объект создан");//при создании объекта будет просто выводиться сообщение "объект создан", конструктор действует на весь проект
            this.setznach(name, ves, coordinates);//вызвали функцию для присвоения значений
            lopator++;
        }
        //можно создавать несколько конструкторов. Создавать их можно сколько угодно внутри одного класса
        public robot()
        {
            //конструктор без параметров, чтобы можно было просто вызвать функцию и передать значения в переменную как будто нет конструктора
            lopator++;
        }

        public robot(int ves)//конструктор с весом
        {
            this.ves = ves;//в переменную присвоили параметр и указали this типа указали на переменную и теперь она может совпадать с параметром. Потом когда конструктор сработает то присвоит это все автоматом
            this.ves += 11;// прибавка к значениям работает, то есть тут можно все что хочу писать в конструкторах. к переменной, а не к параметру прибавили
            lopator++;
        }

        //модификатор static !!!!!!!!!!!!!!!!!!!!!
        //если пишем static то это означает функция будет принадлежать к классу в целом а не к объекту

        public static int lopator; //теперь мы имеем доступ к этой переменной через название класса. То есть не через свойства объекта, а просто как переменная. В другом классе можно написать robot.lopator и дальше присвоить значение 
        //есть и другие статические переменные, например число ПИ, они встроены
        public static void Print()
        {
            System.Console.WriteLine("Я тут");
        }
        //this нельзя использовать вместе с static будет ошибка
        public void print2()
        {
            System.Console.WriteLine("Вес робота пылесос: " + this.ves);
        }
        //static сохраняет свойство и в других объектах и файлах, при переходе между страницами на сайтах, и при переходе между уровнями если в играх
        //this нельзя использовать вместе с static будет ошибка
        //подсчет объектов

        //Аксессоры!!!!!!!!!!!!!
        //с помощью аксессоров мы устанавливать или получать значения из и в переменные
        //можно создать аксессор для любого из полей
        //потом написать что будет происходить при получении данных из этого поля и что будет происходить при установке данных внутрь этого поля
        // у аксессора также есть модификатор доступа обычно указываем public чтобы был доступ через объекты
        public int Ves//создали аксессор, написали модификатор доступа, потом тип данных, потом назнвание, в названии аксессора пишем название переменной объекта но с большой буквы, скобки не пишем, так как это не функция, вообще можно писать любое название с любыми символами, но лучше писать аксессор с таким же названием переменной но с большой буквы, так как это считается хорошим тоном написания кода
        {
            get//будет срабатывать при попытке получения данных из поля
            {
                System.Console.Write("Результат: ");
                return this.ves;//будет возвращаться значения из поля ves. При обращении к аксессору Ves будет выводиться значения поля ves. Также можно обращаться и к другим полям, но могут быть ошибки изза несответсия типов
            }
            set//будет срабатывать в момент когда мы будем что-то устанавливать что-то внутрь аксессора
            {
                if (value < 1)
                {
                    this.ves = 1;
                }
                else if (value > 5000)
                {
                    this.ves = 5000; //доп условие, если значение больше 5000 то вернем значение 5000
                }
                else
                    this.ves = value;
                //устанавливаем значения в поле ves,  будем устанавливать с помощью параметра value, до этого он нигде не был создан, этот параметр который по умолчанию передается в аксессоры, то есть он есть в аксессорах по умолчанию, и он передает значения от пользователя
                // мы это значение получаем и устанавливаем внутрь переменной ves. 
                //теперь при обращении к аксессору Ves мы будет или получать данные из поля ves или устанавливать данные в это поле введенное пользователем
                //суть аксессора в том, что при вводе значения от пользователя в set можно добавить условие какое-то(оно будет служить как бы защитой) или что либо другое, циклы функции и тд
                //также можно прописать условие(или что-то другое, так циклы функции и тд) при получении значения через get

            }
        }
        //аксессоры пробоую на объекте kot
        //вообще можно и создавать отдельные функции для проверок ввода и вывода, но через аксессоры удобнее это сделать

        //отдельный аксессор
        public int Width
        {
            get; set;//пустой аксессор просто для установки и получения данных без лишних условий. Также тут можно разграничить модификаторы доступа, и тогда например get полчение данных не будет доступно если написать private get, тоже самое с set, и тогда нельзя будет значение устанавливать
        }

        //НАСЛЕДОВАНИЕ КЛАССОВ ОЧЕНЬ ВАЖНО

        //наследование - это когда есть клас родитель и есть клас наследник и он будет все наследовать от класса родителя
        //можно создать дополнительный клас, наследник будет наследовать все поля, методы фукнции, конструкторы, аксессоры от класса родителя. Также он иметь свои поля методы конструкторы, аксессоры и тд
        //для чего это нужно: например есть объект робот с дополнительными функциями, которых нет у других роботов, и было бы логично для него сделать дополнительный (наследующий)клас и прописать дополнительные функции дополнительном (наследующем)классе, так как с основном классе пишутся только стандартные функции. Можно конечно сделать просто отдельный клас не наследник, но пришлось бы переписывать все основные функции заново, и еще дополнительные которые нам нужны. 
        //класс наследние создается в отдельном файле

        //модификатор доступа protected!!!!!!!
        //protected переменные или объекты или функции или аксессоры и тд будут доступны в текущем классе родителе и в классах наследниках
        protected string FIO; //создали переменную которая будет доступна в текущем классе родителе и в классах наследниках для объектов
        protected static int dlina;
        //если переменная с модификатором доступа, то эта переменная только для свойства объекта, и вызвать функцию с этой переменной нельзя. Но если прописать модификатор static, то можно будет обратиться к этому полю через название класса.


        //создали аксессор для темы списки объектов
        public string Name
        {
            get
            {
                return name;
            }
            private set { }

        }



    }
}